package main

import (
	"fmt"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var structRegex = regexp.MustCompile(`// #REFLECT\(\)\sstruct (\w*) {([\w\s;,]*)};`)
var titleCase = cases.Title(language.AmericanEnglish, cases.NoLower)

func rglob(dir string, ext string) ([]string, error) {
	var files []string
	err := filepath.Walk(dir, func(path string, f os.FileInfo, err error) error {
		if filepath.Ext(path) == ext {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

func main() {
	handleError := func(err error) {
		if err != nil {
			panic(err)
		}
	}

	headerFilePaths, err := rglob("src", ".hpp")
	handleError(err)

	genFile, _ := os.OpenFile(filepath.Join("src", "generated", "state.generated.hpp"), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	_, _ = genFile.WriteString(`#pragma once

// DO NOT EDIT THIS FILE! It is automatically generated by tools/meta.go

static void register_generated_reflection() {
`)

	for _, path := range headerFilePaths {
		fmt.Println("Scanning header file: ", path)

		fileBytes, err := ioutil.ReadFile(path)
		text := string(fileBytes)
		structDefs := structRegex.FindAllStringSubmatch(text, -1)

		for _, structDef := range structDefs {
			var fieldNames []string
			structName := structDef[1]
			structBody := structDef[2]

			fmt.Println("	Found struct: ", structName)

			varDefs := strings.Split(structBody, ";")

			_, _ = genFile.WriteString(fmt.Sprintf(`	entt::meta<%s>()`, structName))
			for _, fieldDef := range varDefs {
				fieldDef = strings.TrimSpace(fieldDef)
				fieldDefSplit := strings.Split(fieldDef, " ")
				if len(fieldDefSplit) < 2 {
					continue
				}

				for _, fieldName := range fieldDefSplit[1:] {
					fieldName = strings.TrimFunc(fieldName, func(r rune) bool { return r == ',' })
					_, _ = genFile.WriteString(fmt.Sprintf(`
		.data<&%[1]s::%[2]s>("%[2]s"_hs)
			.prop("tooltip"_hs, "%[3]s"sv)`, structName, fieldName, titleCase.String(fieldName)))
					fieldNames = append(fieldNames, fieldName)
				}
			}

			_, _ = genFile.WriteString(`;
`)

			// 			_, _ = genFile.WriteString(`;
			// `)
		}
		handleError(err)
	}

	_, _ = genFile.WriteString(`
}
`)

	_ = genFile.Close()
}
