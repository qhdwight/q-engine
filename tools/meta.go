package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func rglob(dir string, ext string) ([]string, error) {
	var files []string
	err := filepath.Walk(dir, func(path string, f os.FileInfo, err error) error {
		if filepath.Ext(path) == ext {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

func main() {
	handleError := func(err error) {
		if err != nil {
			panic(err)
		}
	}

	matches, err := rglob("src", ".hpp")
	handleError(err)

	genFile, _ := os.OpenFile(filepath.Join("src", "generated", "state.generated.hpp"), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	_, _ = genFile.WriteString(`#pragma once

// DO NOT EDIT THIS FILE! It is automatically generated.

static void register_generated_reflection() {
`)

	for _, match := range matches {
		text, err := ioutil.ReadFile(match)
		structRegex := regexp.MustCompile(`// #REFLECT\(\)\sstruct (\w*) {([\w\s;]*)};`)
		structDefs := structRegex.FindAllStringSubmatch(string(text), -1)

		for _, structDef := range structDefs {
			structName := structDef[1]
			structBody := structDef[2]

			varDefs := strings.Split(structBody, ";")

			_, _ = genFile.WriteString(fmt.Sprintf(`	entt::meta<%s>()`, structName))
			for _, varDef := range varDefs {
				varDef = strings.TrimSpace(varDef)
				varDefSplit := strings.Split(varDef, " ")
				if len(varDefSplit) < 2 {
					continue
				}

				_, _ = genFile.WriteString(fmt.Sprintf(`
			.data<&%s::%[2]s>("%[2]s"_hs)`, structName, varDefSplit[1]))
			}
			_, _ = genFile.WriteString(`;
`)
		}
		handleError(err)
	}

	_, _ = genFile.WriteString(`
}
`)

	_ = genFile.Close()
}
